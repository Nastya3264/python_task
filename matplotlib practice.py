import numpy as np
import matplotlib.pyplot as plt

# Задание № 1
# зададим два массива одинакового размера
x = np.linspace(0, 5, 10)  # массив 10 чисел от 0 до 5 с равным шагом
y = x**2  # массив из квадратов каждого числа массива х
print(x)
print(y)

# построим график для пары точек (x_i, y_i)

# для начала используем функцию figure()
plt.figure()

# затем передаем функции plot параметры х, y - значения массивов одинакового размера,
# 'r' - красный цвет линии
plt.plot(x, y, 'r')

plt.xlabel('x')  # метка для Ох наз-ся х
plt.ylabel('y')
plt.title('title_1')  # название заголовка графика
# plt.show()

# Задание №2 (еще один вариант построения предыдущего графика)
# создаем объект фигура и на нее добавим оси и сам график

# воспользуемся методом plt.figure
fig = plt.figure()

# у созданного объекта добавляем метод add_axes
axes = fig.add_axes([0.1, 0.1, 0.8, 0.8])  # left, bottom, width, height (range 0 to 1)
# это будут относительные положения на всем графике,
# т.е. (0,1 0,1) - начало координат, (0.8, 0.8) - график занимает 80% по ширине и высоте (оставили место для подписей)

# у созданного объекта "оси" вызываем функцию plot
axes.plot(x, y, 'r')

axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title_2')  # чтобы не отображалась строка <matplotlib.text.Text at ...> в конце можно поставить ;
# но по-моему она и так не отображается...
# plt.show()

# Задание №3 (с помощью предыдущего подхода создадим два графика на одной картинке)

# создаем фигуру
fig = plt.figure()

# создаем два набора осей
axes1 = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # main axes - главная ось (большая)
axes2 = fig.add_axes([0.2, 0.5, 0.4, 0.3]) # inset axes - внутренняя ось (маленькая)
# 0.2 - отступаем 20% от левого края, 0.5 - 50% от нижнего, ширина 0.4 и высота 0.3


# main figure - указываем параметры для 1 графика
axes1.plot(x, y, 'r')
axes1.set_xlabel('x')
axes1.set_ylabel('y')
axes1.set_title('title_3')

# insert - указываем параметры для 2 графика
axes2.plot(y, x, 'g') # переставили параметры у и х, зеленым цветом
axes2.set_xlabel('y')
axes2.set_ylabel('x')
axes2.set_title('insert title')
# plt.show()


# Задание №4 (создадим два графика на отдельных картинках)
# для этого используем функцию subplots
fig, axes = plt.subplots(nrows=1, ncols=2)  # указываем количество строк и столбцов

# далее можем (например, в цикле) указывать параметры каждого из графиков
# (если бы, к примеру, у нас бы были списки из массивов, то можно было бы два разных графика построить,
# но для простоты построим одинаковые)
for ax in axes:
    ax.plot(x, y, 'r')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('title_4')
fig.tight_layout() # функция помогает расположить графики так, чтобы элементы не пересекались
# plt.show()

# Задание №5 (настройка размеров графика)

fig, axes = plt.subplots(figsize=(12, 3))  # укажем размер фигуры через figsize (измеряется в дюймах)
# для каждого экрана есть параметр dpi(ppi)-точек(пикселей) на дюйм, который дюймы переводит в точное число пикселей

axes.plot(x, y, 'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title_5')
# plt.show()

# Задание №6 (Два графика на одной картинке с дополнительной легендой)
# для этого при вызове функции plot указываем параметр label

fig, ax = plt.subplots()

ax.plot(x, x**2, label="y = x**2")
ax.plot(x, x**3, label="y = x**3")
ax.legend(loc=2)  # указываем где эта функция размещается
# место расположения легенды определяется параметром loc, которое может принимать одно из нескольких значений
# Код 2 означает upper left corner
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('title')
# plt.show()

# Задание №7 (построение гистограмм)
n = np.random.randn(100000)  # сгенерируем 100000 случайных чисел
fig, axes = plt.subplots(1, 2, figsize=(12, 4)) # построим два графика с 1 стр и 2 стб, размером (12, 4)

# строим график 1
# у осей вместо функции plot теперь функция hist
axes[0].hist(n)
axes[0].set_title("Default histogram") # заголовок
axes[0].set_xlim((min(n), max(n))) # min max значения по оси х

# строим график 2 (кумулятивная гистограмма - гистограмма с накоплением
# (т.е. каждый стб содержит сумму предыдущих частот))
axes[1].hist(n, cumulative=True, bins=50)  # bins - кол-во столбцов
axes[1].set_title("Cumulative detailed histogram")
axes[1].set_xlim((min(n), max(n)))
plt.show()

